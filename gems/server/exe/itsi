#!/usr/bin/env ruby
# frozen_string_literal: true

require "rack"
require "optparse"
require "etc"
require 'uri'

# Default options used when starting Osprey from the CLI using `osprey`
DEFAULT_OPTIONS = {
  # Number of workers
  workers: 1,
  # Number of threads per worker
  threads: 1,
  # Graceful shutdown timeout
  shutdown_timeout: 5,
  # Binds
  binds: ["http://0.0.0.0:3000"],
  # Preload
  preload: true,
  # Rackup file
  rackup_file: "config.ru",
  # Use scheduler
  use_scheduler: false,
  # Scheduler class
  scheduler_class: "Itsi::Scheduler"
}

options = DEFAULT_OPTIONS.to_a.select(&:last).to_h

# Define the option parser
OptionParser.new do |opts|
  opts.banner = "Usage: script.rb [options]"

  opts.on("-w", "--workers WORKERS", Integer, "Number of workers (default: #{options[:workers]})") do |w|
    options[:workers] = w
  end

  opts.on("-t", "--threads THREADS", Integer, "Number of threads (default: #{options[:threads]})") do |t|
    options[:threads] = t
  end

  opts.on("-r", "--rackup_file FILE", String, "Rackup file to use (default: #{options[:rackup_file]})") do |rf|
    options[:rackup_file] = rf
  end

  opts.on("-f", "--use_fiber_scheduler PORT", TrueClass,
          "Port for the application (default: #{options[:use_scheduler]})") do |p|
    options[:use_scheduler] = p
  end

  opts.on("--scheduler_class CLASS", String, "Scheduler class to use (default: #{options[:scheduler_class]})") do |scheduler_class|
    options[:scheduler_class] =  Kernel.const_get(scheduler_class)
  end

  opts.on("--no-preload", FalseClass, "Disable preloading the application") do |no_preload|
    options[:preload] = no_preload
  end

  opts.on("--http_port HTTP_PORT", Integer, "HTTP port for the application (default: #{options[:http_port]})") do |hp|
    options[:http_port] = hp
  end

  opts.on("-c", "--cert_path CERT_PATH", String, "Path to the SSL certificate file (must follow a --bind option)") do |cp|
    if options[:binds].empty?
      raise OptionParser::InvalidOption, "--cert_path must follow a --bind"
    end

    # Modify the last bind entry to add/update the cert query parameter
    uri = URI.parse("http://#{options[:binds].last}") # Ensure valid URI parsing
    params = URI.decode_www_form(uri.query.to_s).to_h
    params["cert"] = cp
    query_string = params.map { |k, v| "#{k}=#{v}" }.join("&")
    options[:binds][-1] = "#{uri.host}?#{query_string}"
  end

  opts.on("-k", "--key_path KEY_PATH", String, "Path to the SSL key file (must follow a --bind option)") do |kp|
    if options[:binds].empty?
      raise OptionParser::InvalidOption, "--key_path must follow a --bind"
    end

    # Modify the last bind entry to add/update the key query parameter
    uri = URI.parse("http://#{options[:binds].last}") # Ensure valid URI parsing
    params = URI.decode_www_form(uri.query.to_s).to_h
    params["key"] = kp
    query_string = params.map { |k, v| "#{k}=#{v}" }.join("&")
    options[:binds][-1] = "#{uri.host}?#{query_string}"
  end

  opts.on("--shutdown_timeout SHUTDOWN_TIMEOUT", String,
          "Graceful timeout period before forcing workers to shutdown") do |shutdown_timeout|
    options[:shutdown_timeout] = shutdown_timeout
  end

  opts.on("--script_name SCRIPT_NAME", String, "Script name to inject into Rack ENV") do |script_name|
    options[:script_name] = script_name
  end

  opts.on("-b", "--bind BIND", String, "Bind address (default: #{options[:binds].join(", ")})") do |bind|
    options[:binds].pop if options[:binds].first.frozen?
    options[:binds] << bind
  end

  opts.on("--help", "Show this help message") do
    puts opts
    exit
  end
end.parse!

# Rack app loader, invoked per worker.
# This is a no-op if preloading is enabled (we just return the preloaded app).
preloader = if options[:preload]
  Array(Rack::Builder.parse_file(options[:rackup_file])).first.method(:itself).to_proc
else
 ->{
   Array(Rack::Builder.parse_file(options[:rackup_file])).first
 }
end

# Make sure osprey is loaded, if not already loaded by the rack_app above.
# Start the Osprey server
require "itsi/server"


begin
  Itsi::Server.new(
    app: preloader,
    **options.except(:preload, :rackup_file)
  ).start
rescue Interrupt
  # Shutdown
end
