require_relative 'test_service_services_pb'  # generated by grpc_tools_ruby_protoc

class TestServiceImpl < Test::TestService::Service
  # Unary: echo back the message  [oai_citation_attribution:2‡Gustavo Caso](https://gustavocaso.dev/posts/grpc-tutorial-with-ruby/)
  def unary_echo(req, _unused_call)
    Test::EchoResponse.new(message: req.message)
  end

  # Client‑streaming: collect all incoming messages into one response  [oai_citation_attribution:3‡Medium](https://alessiobussolari.medium.com/integrating-grpc-with-ruby-on-rails-2b2a203107d5?utm_source=chatgpt.com)
  def client_stream(stream, _call)
    msgs = stream.map(&:message)
    Test::StreamResponse.new(messages: msgs)
  end

  # Server‑streaming: send back one StreamResponse per incoming request, with each char  [oai_citation_attribution:4‡Medium](https://alessiobussolari.medium.com/integrating-grpc-with-ruby-on-rails-2b2a203107d5?utm_source=chatgpt.com)
  def server_stream(req, _call)
    Enumerator.new do |y|
      req.message.each_char { |c| y << Test::StreamResponse.new(messages: [c]) }
    end
  end

  # Bidirectional: for each incoming EchoRequest, immediately echo it back  [oai_citation_attribution:5‡Medium](https://alessiobussolari.medium.com/integrating-grpc-with-ruby-on-rails-2b2a203107d5?utm_source=chatgpt.com)
  def bidi_stream(stream, _call)
    Enumerator.new do |y|
      stream.each { |req| y << Test::EchoResponse.new(message: req.message.upcase) }
    end
  end
end
